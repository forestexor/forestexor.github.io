// 行列クラス
class CMatrix{
	// コンストラクタ
	constructor(	_11 = 1, _12 = 0, _13 = 0, _14 = 0,
					_21 = 0, _22 = 1, _23 = 0, _24 = 0,
					_31 = 0, _32 = 0, _33 = 1, _34 = 0,
					_41 = 0, _42 = 0, _43 = 0, _44 = 1
				){
		this._11 = _11; this._12 = _12; this._13 = _13; this._14 = _14;
		this._21 = _21; this._22 = _22; this._23 = _23; this._24 = _24;
		this._31 = _31; this._32 = _32; this._33 = _33; this._34 = _34;
		this._41 = _41; this._42 = _42; this._43 = _43; this._44 = _44;
	}
	
	// 行列配列を返す
	get f(){
		return new Float32Array([
				this._11, this._12, this._13, this._14,
				this._21, this._22, this._23, this._24,
				this._31, this._32, this._33, this._34,
				this._41, this._42, this._43, this._44
			]);
	}
	
	// 自身を初期化する
	Identity(){
		this._11 = 1; this._12 = 0; this._13 = 0; this._14 = 0;
		this._21 = 0; this._22 = 1; this._23 = 0; this._24 = 0;
		this._31 = 0; this._32 = 0; this._33 = 1; this._34 = 0;
		this._41 = 0; this._42 = 0; this._43 = 0; this._44 = 1;
	}
	
	// 引数に渡された行列の値を自身にコピーする
	Set( m ){
		this._11 = m._11; this._12 = m._12; this._13 = m._13; this._14 = m._14;
		this._21 = m._21; this._22 = m._22; this._23 = m._23; this._24 = m._24;
		this._31 = m._31; this._32 = m._32; this._33 = m._33; this._34 = m._34;
		this._41 = m._41; this._42 = m._42; this._43 = m._43; this._44 = m._44;
	}
	
	// 行列どうしをかける
	// 引数1 : 乗算結果を格納する行列
	// 引数2 : 乗算元となる行列1
	// 引数3 : 乗算元となる行列2
	static Multiply( d, m0, m1 ){
		d._11 = ((m1._11 * m0._11) + (m1._12 * m0._21) + (m1._13 * m0._31) + (m1._14 * m0._41));
		d._12 = ((m1._11 * m0._12) + (m1._12 * m0._22) + (m1._13 * m0._32) + (m1._14 * m0._42));
		d._13 = ((m1._11 * m0._13) + (m1._12 * m0._23) + (m1._13 * m0._33) + (m1._14 * m0._43));
		d._14 = ((m1._11 * m0._14) + (m1._12 * m0._24) + (m1._13 * m0._34) + (m1._14 * m0._44));
		
		d._21 = ((m1._21 * m0._11) + (m1._22 * m0._21) + (m1._23 * m0._31) + (m1._24 * m0._41));
		d._22 = ((m1._21 * m0._12) + (m1._22 * m0._22) + (m1._23 * m0._32) + (m1._24 * m0._42));
		d._23 = ((m1._21 * m0._13) + (m1._22 * m0._23) + (m1._23 * m0._33) + (m1._24 * m0._43));
		d._24 = ((m1._21 * m0._14) + (m1._22 * m0._24) + (m1._23 * m0._34) + (m1._24 * m0._44));
		
		d._31 = ((m1._31 * m0._11) + (m1._32 * m0._21) + (m1._33 * m0._31) + (m1._34 * m0._41));
		d._32 = ((m1._31 * m0._12) + (m1._32 * m0._22) + (m1._33 * m0._32) + (m1._34 * m0._42));
		d._33 = ((m1._31 * m0._13) + (m1._32 * m0._23) + (m1._33 * m0._33) + (m1._34 * m0._43));
		d._34 = ((m1._31 * m0._14) + (m1._32 * m0._24) + (m1._33 * m0._34) + (m1._34 * m0._44));
		
		d._41 = ((m1._41 * m0._11) + (m1._42 * m0._21) + (m1._43 * m0._31) + (m1._44 * m0._41));
		d._42 = ((m1._41 * m0._12) + (m1._42 * m0._22) + (m1._43 * m0._32) + (m1._44 * m0._42));
		d._43 = ((m1._41 * m0._13) + (m1._42 * m0._23) + (m1._43 * m0._33) + (m1._44 * m0._43));
		d._44 = ((m1._41 * m0._14) + (m1._42 * m0._24) + (m1._43 * m0._34) + (m1._44 * m0._44));
	}
	
	// 移動行列を作成する
	// 引数1 : 結果を格納する行列
	// 引数2 : 3次元座標ベクトル
	static Translation( m, v ){
		m._11 = 1.0;
		m._12 = 0.0;
		m._13 = 0.0;
		m._14 = 0.0;

		m._21 = 0.0;
		m._22 = 1.0;
		m._23 = 0.0;
		m._24 = 0.0;

		m._31 = 0.0;
		m._32 = 0.0;
		m._33 = 1.0;
		m._34 = 0.0;

		m._41 = v[0];
		m._42 = v[1];
		m._43 = v[2];
		m._44 = 1.0;
	}
	
	// X回転行列を作成する
	// 引数1 : 結果を格納する行列
	// 引数2 : X軸の回転角度
	static RotationX( m, r ){
		const sinX = Math.sin( r );
		const cosX = Math.cos( r );
		
		m._11 = 1.0;
		m._12 = 0.0;
		m._13 = 0.0;
		m._14 = 0.0;

		m._21 = 0.0;
		m._22 = cosX;
		m._23 = sinX;
		m._24 = 0.0;

		m._31 = 0.0;
		m._32 = -sinX;
		m._33 = cosX;
		m._34 = 0.0;

		m._41 = 0.0;
		m._42 = 0.0;
		m._43 = 0.0;
		m._44 = 1.0;
	}
	
	// Y回転行列を作成する
	// 引数1 : 結果を格納する行列
	// 引数2 : Y軸の回転角度
	static RotationY( m, r ){
		const sinY = Math.sin( r );
		const cosY = Math.cos( r );
		
		m._11 = cosY;
		m._12 = 0.0;
		m._13 = -sinY;
		m._14 = 0.0;

		m._21 = 0.0;
		m._22 = 1.0;
		m._23 = 0.0;
		m._24 = 0.0;

		m._31 = sinY;
		m._32 = 0.0;
		m._33 = cosY;
		m._34 = 0.0;

		m._41 = 0.0;
		m._42 = 0.0;
		m._43 = 0.0;
		m._44 = 1.0;
	}
	
	// Z回転行列を作成する
	// 引数1 : 結果を格納する行列
	// 引数2 : Z軸の回転角度
	static RotationZ( m, r ){
		const sinZ = Math.sin( r );
		const cosZ = Math.cos( r );

		m._11 = cosZ;
		m._12 = sinZ;
		m._13 = 0.0;
		m._14 = 0.0;

		m._21 = -sinZ;
		m._22 = cosZ;
		m._23 = 0.0;
		m._24 = 0.0;

		m._31 = 0.0;
		m._32 = 0.0;
		m._33 = 1.0;
		m._34 = 0.0;

		m._41 = 0.0;
		m._42 = 0.0;
		m._43 = 0.0;
		m._44 = 1.0;

	}
	
	// XYZ回転行列を作成する
	// 引数1 : 結果を格納する行列
	// 引数2 : 3次元角度ベクトル
	static RotationXYZ( m, v ){
	}
	
	// クォータニオン行列を作成する
	// 引数1 : 結果を格納する行列
	// 引数2 : 3次元角度ベクトル
	static RotationQ( m, v ){
		const hx = (v[0] * 0.5);
		const hy = (v[1] * 0.5);
		const hz = (v[2] * 0.5);
		const x = (Math.sin(hy) * Math.cos(hx) * Math.sin(hz) + Math.cos(hy) * Math.sin(hx) * Math.cos(hz));
		const y = (Math.sin(hy) * Math.cos(hx) * Math.cos(hz) - Math.cos(hy) * Math.sin(hx) * Math.sin(hz));
		const z = (Math.cos(hy) * Math.cos(hx) * Math.sin(hz) - Math.sin(hy) * Math.sin(hx) * Math.cos(hz));
		const w = (Math.cos(hy) * Math.cos(hx) * Math.cos(hz) + Math.sin(hy) * Math.sin(hx) * Math.sin(hz));

		m._11 = 1.0 - 2.0 * (y * y + z * z);
		m._12 = 2.0 * (x * y + z * w);
		m._13 = 2.0 * (x * z - y * w);
		m._14 = 0.0;

		m._21 = 2.0 * (x * y - z * w);
		m._22 = 1.0 - 2.0 * (x * x + z * z);
		m._23 = 2.0 * (y *z + x * w);
		m._24 = 0.0;

		m._31 = 2.0 * (x * z + y * w);
		m._32 = 2.0 * (y * z - x * w);
		m._33 = 1.0 - 2.0 * (x * x + y * y);
		m._34 = 0.0;

		m._41 = 0.0;
		m._42 = 0.0;
		m._43 = 0.0;
		m._44 = 1.0;
	}
	
	// スケール行列を作成する
	// 引数1 : 結果を格納する行列
	// 引数2 : 3次元スケールベクトル
	static Scaling( m, v ){
		m._11 = v[0];
		m._12 = 0.0;
		m._13 = 0.0;
		m._14 = 0.0;

		m._21 = 0.0;
		m._22 = v[1];
		m._23 = 0.0;
		m._24 = 0.0;

		m._31 = 0.0;
		m._32 = 0.0;
		m._33 = v[2];
		m._34 = 0.0;

		m._41 = 0.0;
		m._42 = 0.0;
		m._43 = 0.0;
		m._44 = 1.0;
	}
	
	// 対象方向に向く行列を得る
	// 引数1 : 結果を格納する行列
	// 引数2 : 自身座標ベクトル
	// 引数3 : 対象位置ベクトル
	// 引数4 : 3次元カメラ上向きベクトル
	static LookAt( m, eye, at, up ){
		let vZ = [ 0.0, 0.0, 0.0 ];
		let vX = [ 0.0, 0.0, 0.0 ];
		let vY = [ 0.0, 0.0, 0.0 ];
		let len = 0.0;
		
		vZ[0] = (eye[0] - at[0]);
		vZ[1] = (eye[1] - at[1]);
		vZ[2] = (eye[2] - at[2]);
		len = (1.0 / Math.sqrt( ((vZ[0]*vZ[0]) + (vZ[1]*vZ[1]) + (vZ[2]*vZ[2])) ));
		vZ[0] = vZ[0] * len;
		vZ[1] = vZ[1] * len;
		vZ[2] = vZ[2] * len;
		
		vX[0] = ((up[1] * vZ[2]) - (up[2] * vZ[1]));
		vX[1] = ((up[2] * vZ[0]) - (up[0] * vZ[2]));
		vX[2] = ((up[0] * vZ[1]) - (up[1] * vZ[0]));
		len = (1.0 / Math.sqrt( ((vX[0]*vX[0]) + (vX[1]*vX[1]) + (vX[2]*vX[2])) ));
		vX[0] = vX[0] * len;
		vX[1] = vX[1] * len;
		vX[2] = vX[2] * len;
		
		vY[0] = ((vZ[1] * vX[2]) - (vZ[2] * vX[1]));
		vY[1] = ((vZ[2] * vX[0]) - (vZ[0] * vX[2]));
		vY[2] = ((vZ[0] * vX[1]) - (vZ[1] * vX[0]));
		
		m._11 = vX[0];
		m._12 = vX[1];
		m._13 = vX[2];
		m._14 = 0.0;

		m._21 = vY[0];
		m._22 = vY[1];
		m._23 = vY[2];
		m._24 = 0.0;

		m._31 = -vZ[0];
		m._32 = -vZ[1];
		m._33 = -vZ[2];
		m._34 = 0.0;
		
		m._41 = 0.0;
		m._42 = 0.0;
		m._43 = 0.0;
		m._44 = 1.0;
	}
	
	// 右手座標系ビュー行列を作成する
	// 引数1 : 結果を格納する行列
	// 引数2 : 3次元カメラ座標ベクトル
	// 引数3 : 3次元カメラ注視点ベクトル
	// 引数4 : 3次元カメラ上向きベクトル
	static LookAtRH( m, eye, at, up ){
		let vZ = [ 0.0, 0.0, 0.0 ];
		let vX = [ 0.0, 0.0, 0.0 ];
		let vY = [ 0.0, 0.0, 0.0 ];
		let len = 0.0;
		
		vZ[0] = (eye[0] - at[0]);
		vZ[1] = (eye[1] - at[1]);
		vZ[2] = (eye[2] - at[2]);
		len = (1.0 / Math.sqrt( ((vZ[0]*vZ[0]) + (vZ[1]*vZ[1]) + (vZ[2]*vZ[2])) ));
		vZ[0] = vZ[0] * len;
		vZ[1] = vZ[1] * len;
		vZ[2] = vZ[2] * len;
		
		vX[0] = ((up[1] * vZ[2]) - (up[2] * vZ[1]));
		vX[1] = ((up[2] * vZ[0]) - (up[0] * vZ[2]));
		vX[2] = ((up[0] * vZ[1]) - (up[1] * vZ[0]));
		len = (1.0 / Math.sqrt( ((vX[0]*vX[0]) + (vX[1]*vX[1]) + (vX[2]*vX[2])) ));
		vX[0] = vX[0] * len;
		vX[1] = vX[1] * len;
		vX[2] = vX[2] * len;
		
		vY[0] = ((vZ[1] * vX[2]) - (vZ[2] * vX[1]));
		vY[1] = ((vZ[2] * vX[0]) - (vZ[0] * vX[2]));
		vY[2] = ((vZ[0] * vX[1]) - (vZ[1] * vX[0]));
		//len = (1.0 / Math.sqrt( ((vY[0]*vY[0]) + (vY[1]*vY[1]) + (vY[2]*vY[2])) ));
		//vY[0] = vY[0] * len;
		//vY[1] = vY[1] * len;
		//vY[2] = vY[2] * len;

		m._11 = vX[0];
		m._12 = vY[0];
		m._13 = vZ[0];
		m._14 = 0.0;

		m._21 = vX[1];
		m._22 = vY[1];
		m._23 = vZ[1];
		m._24 = 0.0;

		m._31 = vX[2];
		m._32 = vY[2];
		m._33 = vZ[2];
		m._34 = 0.0;
		
		m._41 = -((vX[0] * eye[0]) + (vX[1] * eye[1]) + (vX[2] * eye[2]));
		m._42 = -((vY[0] * eye[0]) + (vY[1] * eye[1]) + (vY[2] * eye[2]));
		m._43 = -((vZ[0] * eye[0]) + (vZ[1] * eye[1]) + (vZ[2] * eye[2]));
		m._44 = 1.0;
	}
	
	// 右手座標系プロジェクション行列を作成する
	// 引数1 : 結果を格納する行列
	// 引数2 : 視野角
	// 引数3 : アスペクト比
	// 引数4 : 描画範囲最小位置（手前）
	// 引数4 : 描画範囲最大位置（奥行き）
	static PerspectiveFovRH( m, fov, aspect, near, far ){
		const t = Math.tan((fov * 0.5));
		const nf = (1.0 / (near - far));
		
		m._11 = (1.0 / (aspect * t));
		m._12 = 0.0;
		m._13 = 0.0;
		m._14 = 0.0;

		m._21 = 0.0;
		m._22 = (1.0 / t);
		m._23 = 0.0;
		m._24 = 0.0;

		m._31 = 0.0;
		m._32 = 0.0;
		m._33 = (near + far) * nf;
		m._34 = -1.0;

		m._41 = 0.0;
		m._42 = 0.0;
		m._43 = (2.0 * far * near * nf);
		m._44 = 0.0;
	}
	
	// ワールド、ビュー、プロジェクション行列を合成する
	// 引数1 : 結果を格納する行列
	// 引数2 : ワールド行列
	// 引数3 : ビュー行列行列
	// 引数4 : プロジェクション行列
	static WVP( m, w, v, p ){
		let t = new CMatrix();
		this.Multiply( t, p, v );
		this.Multiply( m, t, w );
	}
	
	// 転置行列を作成する
	// 引数1 : 結果を格納する行列
	// 引数2 : 元となる行列
	static Transpose( m, _m ){
//		m._11 = _m._11;
		m._12 = _m._21;
		m._13 = _m._31;
		m._14 = _m._41;
		
		m._21 = _m._12;
//		m._22 = _m._22;
		m._23 = _m._32;
		m._24 = _m._42;
		
		m._31 = _m._13;
		m._32 = _m._23;
//		m._33 = _m._33;
		m._34 = _m._43;
		
		m._41 = _m._14;
		m._42 = _m._24;
		m._43 = _m._34;
//		m._44 = _m._44;
	}
	
	// 逆行列を作成する
	// 引数1 : 結果を格納する行列
	// 引数2 : 元となる行列
	static Inverse( m, _m ){
		let detA	= (_m._11 * _m._22*_m._33 * _m._44) + (_m._11 * _m._23 * _m._34 * _m._42) + (_m._11 * _m._24 * _m._32 * _m._43)
					+ (_m._12 * _m._21*_m._34 * _m._43) + (_m._12 * _m._23 * _m._31 * _m._44) + (_m._12 * _m._24 * _m._33 * _m._41)
					+ (_m._13 * _m._21*_m._32 * _m._44) + (_m._13 * _m._22 * _m._34 * _m._41) + (_m._13 * _m._24 * _m._31 * _m._42)
					+ (_m._14 * _m._21*_m._33 * _m._42) + (_m._14 * _m._22 * _m._31 * _m._43) + (_m._14 * _m._23 * _m._32 * _m._41)
					- (_m._11 * _m._22*_m._34 * _m._43) - (_m._11 * _m._23 * _m._32 * _m._44) - (_m._11 * _m._24 * _m._33 * _m._42)
					- (_m._12 * _m._21*_m._33 * _m._44) - (_m._12 * _m._23 * _m._34 * _m._41) - (_m._12 * _m._24 * _m._31 * _m._43)
					- (_m._13 * _m._21*_m._34 * _m._42) - (_m._13 * _m._22 * _m._31 * _m._44) - (_m._13 * _m._24 * _m._32 * _m._41)
					- (_m._14 * _m._21*_m._32 * _m._43) - (_m._14 * _m._22 * _m._33 * _m._41) - (_m._14 * _m._23 * _m._31 * _m._42);

		if( 0.0 == detA ){ return; }
		detA = (1.0 / detA);

		m._11	= (_m._22 * _m._33 * _m._44) + (_m._23 * _m._34 * _m._42) + (_m._24 * _m._32 * _m._43)
				- (_m._22 * _m._34 * _m._43) - (_m._23 * _m._32 * _m._44) - (_m._24 * _m._33 * _m._42);
		m._12	= (_m._12 * _m._34 * _m._43) + (_m._13 * _m._32 * _m._44) + (_m._14 * _m._33 * _m._42)
				- (_m._12 * _m._33 * _m._44) - (_m._13 * _m._34 * _m._42) - (_m._14 * _m._32 * _m._43);
		m._13	= (_m._12 * _m._23 * _m._44) + (_m._13 * _m._24 * _m._42) + (_m._14 * _m._22 * _m._43)
				- (_m._12 * _m._24 * _m._43) - (_m._13 * _m._22 * _m._44) - (_m._14 * _m._23 * _m._42);
		m._14	= (_m._12 * _m._24 * _m._33) + (_m._13 * _m._22 * _m._34) + (_m._14 * _m._23 * _m._32)
				- (_m._12 * _m._23 * _m._34) - (_m._13 * _m._24 * _m._32) - (_m._14 * _m._22 * _m._33);
		
		m._21	= (_m._21 * _m._34 * _m._43) + (_m._23 * _m._31 * _m._44) + (_m._24 * _m._33 * _m._41)
				- (_m._21 * _m._33 * _m._44) - (_m._23 * _m._34 * _m._41) - (_m._24 * _m._31 * _m._43);
		m._22	= (_m._11 * _m._33 * _m._44) + (_m._13 * _m._34 * _m._41) + (_m._14 * _m._31 * _m._43)
				- (_m._11 * _m._34 * _m._43) - (_m._13 * _m._31 * _m._44) - (_m._14 * _m._33 * _m._41);
		m._23	= (_m._11 * _m._24 * _m._43) + (_m._13 * _m._21 * _m._44) + (_m._14 * _m._23 * _m._41)
				- (_m._11 * _m._23 * _m._44) - (_m._13 * _m._24 * _m._41) - (_m._14 * _m._21 * _m._43);
		m._24	= (_m._11 * _m._23 * _m._34) + (_m._13 * _m._24 * _m._31) + (_m._14 * _m._21 * _m._33)
				- (_m._11 * _m._24 * _m._33) - (_m._13 * _m._21 * _m._34) - (_m._14 * _m._23 * _m._31);
		
		m._31	= (_m._21 * _m._32 * _m._44) + (_m._22 * _m._34 * _m._41) + (_m._24 * _m._31 * _m._42)
				- (_m._21 * _m._34 * _m._42) - (_m._22 * _m._31 * _m._44) - (_m._24 * _m._32 * _m._41);
		m._32	= (_m._11 * _m._34 * _m._42) + (_m._12 * _m._31 * _m._44) + (_m._14 * _m._32 * _m._41)
				- (_m._11 * _m._32 * _m._44) - (_m._12 * _m._34 * _m._41) - (_m._14 * _m._31 * _m._42);
		m._33	= (_m._11 * _m._22 * _m._44) + (_m._12 * _m._24 * _m._41) + (_m._14 * _m._21 * _m._42)
				- (_m._11 * _m._24 * _m._42) - (_m._12 * _m._21 * _m._44) - (_m._14 * _m._22 * _m._41);
		m._34	= (_m._11 * _m._24 * _m._32) + (_m._12 * _m._21 * _m._34) + (_m._14 * _m._22 * _m._31)
				- (_m._11 * _m._22 * _m._34) - (_m._12 * _m._24 * _m._31) - (_m._14 * _m._21 * _m._32);
		
		m._41	= (_m._21 * _m._33 * _m._42) + (_m._22 * _m._31 * _m._43) + (_m._23 * _m._32 * _m._41)
				- (_m._21 * _m._32 * _m._43) - (_m._22 * _m._33 * _m._41) - (_m._23 * _m._31 * _m._42);
		m._42	= (_m._11 * _m._32 * _m._43) + (_m._12 * _m._33 * _m._41) + (_m._13 * _m._31 * _m._42)
				- (_m._11 * _m._33 * _m._42) - (_m._12 * _m._31 * _m._43) - (_m._13 * _m._32 * _m._41);
		m._43	= (_m._11 * _m._23 * _m._42) + (_m._12 * _m._21 * _m._43) + (_m._13 * _m._22 * _m._41)
				- (_m._11 * _m._22 * _m._43) - (_m._12 * _m._23 * _m._41) - (_m._13 * _m._21 * _m._42);
		m._44	= (_m._11 * _m._22 * _m._33) + (_m._12 * _m._23 * _m._31) + (_m._13 * _m._21 * _m._32)
				- (_m._11 * _m._23 * _m._32) - (_m._12 * _m._21 * _m._33) - (_m._13 * _m._22 * _m._31);

		m._11 = m._11 * detA;
		m._12 = m._12 * detA;
		m._13 = m._13 * detA;
		m._14 = m._14 * detA;

		m._21 = m._21 * detA;
		m._22 = m._22 * detA;
		m._23 = m._23 * detA;
		m._24 = m._24 * detA;

		m._31 = m._31 * detA;
		m._32 = m._32 * detA;
		m._33 = m._33 * detA;
		m._34 = m._34 * detA;

		m._41 = m._41 * detA;
		m._42 = m._42 * detA;
		m._43 = m._43 * detA;
		m._44 = m._44 * detA;
	}

}




